import * as _ from 'lamb';
import { fetch } from 'undici';

import { update } from 'es/update.mjs';
import { spotlightEndpoint, confidenceValues } from 'conf/config.mjs';
import { getLength, mergeWithMerge, stringify } from '@svizzle/utils';
/**
 * The resource object that the spotlight tool responds with. Each resource corresponds to a DBpedia URI.
 * @typedef SpotlightResource
 * @type {Object}
 * @property {string} @URI - the Unique Resource Identifier for this resource.
 * @property {number} @support - the support for the annotated resource (see {@link SpotlightAnnotation})
 * @property {string} @types - the types the resource belongs to in the ontology.
 * @property {string} @surfaceForm - the original string used to produce this resource.
 * @property {number} @offset - the index at which the surface form was found in the provided text.
 * @property {number} @similarityScore - cosine similarity between the context vectors and the context surrounding the surface form.
 * @property {number} @percentageOfSecondRank - the relative difference in topic score between the first and the second ranked resource.
 */

/**
 * The annotation response. This object is the response to a call made when annotating a piece of text.
 * @typedef SpotlightAnnotation
 * @type {Object}
 * @property {string} text - text to be annotated.
 * @property {string} confidence - confidence score for disambiguation / linking.
 * @property {number} support - how prominent is this entity in Lucene Model, i.e. number of inlinks in Wikipedia
 * @property {string} types - types filter (Eg.DBpedia:Place).
 * @property {string} sparql - SPARQL filtering
 * @property {string} policy - (whitelist) select all entities that have the same type; (blacklist) - select all entities that have not the same type.
 * @property {SpotlightResource[]} Resources - the resources found for the supplied text.
 */

/**
 * @function castAnnotation
 * @description the Spotlight API returns the annotations with certan values cast as strings.
 * This function recasts the values back to their appropriate types.
 * @param {SpotlightAnnotation} annotation
 * @returns the Spotlight annotation, correctly parsed and casted
 */
const castAnnotation = (annotation) => {
	// FIXME: Use mapping to determine which types to cast
	const Resources = annotation.Resources
		? annotation.Resources.map((r) => {
			return {
				...r,
				'@support': parseInt(r['@support']),
				'@offset': parseFloat(r['@offset']),
				'@similarityScore': parseFloat(r['@similarityScore']),
				'@percentageOfSecondRank': parseFloat(
					r['@percentageOfSecondRank']
				),
			};
		})
		: null;
	return {
		...annotation,
		'@confidence': parseInt(100 * parseFloat(annotation['@confidence'])),
		'@support': parseInt(annotation['@support']),
		Resources,
	};
};
/**
 * @function annotate
 * @description Returns an annotation object for the specified inputs.
 * @param {string} text - Text to annotate
 * @param {float} confidence - Confidence with which to annotate
 * @param {Object} [options] - Options object for the annotation process
 * @param {string} [options.endpoint] - Endpoint url where the Spotlight process runs. Defaults to the Docker container running on Nesta's EC2 instance.
 * @returns {SpotlightAnnotation} Spotlight annotation for given input paramaters
 */
export const annotate = async (
	text,
	confidence,
	{ endpoint = spotlightEndpoint } = {}
) => {
	const url = new URL(endpoint);
	const body = `text=${text}&confidence=${confidence}`;
	const response = await fetch(url, {
		method: 'POST',
		headers: {
			Accept: 'application/json',
			'content-type': 'application/x-www-form-urlencoded',
		},
		body: encodeURI(body),
	});
	if (!response.ok) {
		throw new Error(`Annotation failed\nResponse: ${stringify(response)}`);
	}
	const annotation = await response.json();
	return castAnnotation(annotation);
};

/**
 * For our purposes, we simplify the {@link SpotlightResource} object.
 * All properties below are the exact same.
 * @typedef ReducedResource
 * @type {Object}
 * @property {string} URI - the Unique Resource Identifier for this resource.
 * @property {string} surfaceForm - the original string used to produce this resource.
 * @property {number} similarityScore - cosine similarity between the context vectors and the context surrounding the surface form.
 * @property {number} percentageOfSecondRank - the relative difference in topic score between the first and the second ranked resource.
 */

/**
 *
 * @typedef ParsedAnnotation
 * @type {Object}
 * @property {ReducedResource[]} results - an array of simplified results.
 * @property {number} confidence - the confidence at which these results were annotated.
 */

/**
 * @function parseAnnotationResults
 * @description this function takes an array of Annotation objects and simplifies them.
 * @param {SpotlightAnnotation} spotlightAnnotation - an object returned by {@link annotate}
 * @returns {ParsedAnnotation} parsed Annotation.
 */
export const parseAnnotationResults = spotlightAnnotation =>
	spotlightAnnotation.Resources
		? _.flatMap(spotlightAnnotation.Resources, result => ({
			confidence: spotlightAnnotation['@confidence'],
			URI: result['@URI'],
			surfaceForm: result['@surfaceForm'],
			similarityScore: result['@similarityScore'],
			percentageOfSecondRank: result['@percentageOfSecondRank'],
		}))
		: [];

/**
 * The final form of resource, this is the same as {@link ReducedResource}, however
 * the confidence property has been added to the objects values.
 * All properties below are the exact same.
 * @typedef DBpediaEntity
 * @type {Object}
 * @property {string} URI - the Unique Resource Identifier for this resource.
 * @property {string} surfaceForm - the original string used to produce this resource.
 * @property {number} similarityScore - cosine similarity between the context vectors and the context surrounding the surface form.
 * @property {number} percentageOfSecondRank - the relative difference in topic score between the first and the second ranked resource.
 * @property {number} confidence - the highest confidence at which this resource could be found. This means that all annotations performed at a lower confidence than the one given here will also produce this annotation.
 */

/**
 * @function reduceAnnotationResults
 * @description Maps {@link ParsedAnnotation} objects using their confidedence.
 * @param {Object.<string, ParsedAnnotation>} parsedAnnotationByConfidence - an object where {@link ReducedResource} objects are mapped by the condience with which they were produced.
 * @returns {DBpediaEntity[]} - a list of annotated entities.
 */
export const reduceAnnotationResults = spotlightTerms => {

	const reduceTerms = _.mapValuesWith(
		_.reduceWith(
			(acc, curr) => curr.confidence > acc.confidence ? curr : acc,
		)
	)

	const countDuplicatesOf = confidence => _.mapValuesWith(
		_.pipe([
			_.filterWith(_.hasKeyValue('confidence', confidence)),
			getLength,
			value => ({ [`duplicates_${confidence}`]: value })
		]),
	)

	const reduceAndCountDuplicates = confidences => _.pipe([
		_.groupBy(_.getKey('URI')),
		_.collect([
			reduceTerms,
			..._.map(confidences, countDuplicatesOf)
		]),
		_.reduceWith(mergeWithMerge),
		_.values
	])

	const reduceAndCountDuplicatesOf = reduceAndCountDuplicates([10, 60])
	const finalResults = reduceAndCountDuplicatesOf(spotlightTerms)
	return finalResults
};


export const annotateText = async (
	text,
	{ endpoint = spotlightEndpoint, includeMetaData = null } = {}
) => {
	const spotLightPromises = _.map(confidenceValues, confidence =>
		annotate(text, confidence, { endpoint, })
	);

	/** @type {SpotlightAnnotation[]} */
	const spotlightResults = (await Promise.all(spotLightPromises)).filter(
		(r) => 'Resources' in r
	);

	/** @type {ParsedAnnotation[]} */
	const reducedTerms = _.pipe([
		_.mapWith(parseAnnotationResults),
		_.flatten,
		reduceAnnotationResults
	])(spotlightResults)

	const metadata =
		includeMetaData && generateMetaData(reducedTerms, spotlightResults);

	return {
		annotations: reducedTerms,
		...(metadata && { metadata }),
	};
};

/**
 * Results for the higher level process of annotating an ElasticSearch document.
 * @typedef documentAnnotationResult
 * @type {Object}
 * @property {Object} document - the ElasticSearch document supplied for annotation.
 * @property {DBpediaEntity[]} annotations - a list of annotations for the supplied document.
 */

/**
 * @function annotateDocument
 * @description takes an Elastic search document from Arxlive and annotates the abstract_article field.
 * @param {Object} doc - an ElasticSearch document from the Arxlive domain.
 * @param {string} field - the field of the docment to use as text for the annotation
 * @param {string} endpoint - the endpoint pointing to the Spotlight REST API.
 * @return {documentAnnotationResult} - the annotations for this document
 */
export const annotateDocument = async (
	doc,
	field,
	{ includeMetaData = null, endpoint = spotlightEndpoint } = {}
) => {
	const annotationData = await annotateText(doc._source[field], { endpoint, includeMetaData });
	return { id: doc._id, ...annotationData }
};

/**
 * @function uploadAnnotatedDocument
 * @description abstracts process of uploading document, to avoid uploading empty annotations
 * @param {Object} annotations - the dbpedia annotations provided by {@link annotatedDocument}
 * @param {string} id - id of document to update
 * @param {string} domain - domain on which to upload
 * @param {*} index - index on which to upload
 * @returns {Promise} a promise indicating status of upload process
 */
export const uploadAnnotatedDocument = async (
	{ annotations, id, metadata },
	fieldName,
	domain,
	index
) => {
	// no point in uploading if the doc/payload is empty
	if (Object.keys(annotations).length === 0) {
		return Promise.resolve();
	}
	return update(domain, index, id, {
		[fieldName]: annotations,
		...(metadata && { [`${fieldName}_metadata`]: metadata }),
	});
};

export const generateMetaData = (reducedTerms, spotlightResults) => {

	const metaReducer = (prev, curr) => {
		return {
			entities_count: prev.entities_count + 1,
			confidence_avg: prev.confidence_avg + curr.confidence,
			confidence_max: curr.confidence > prev.confidence_max ? curr.confidence : prev.confidence_max,
			confidence_min: curr.confidence < prev.confidence_min ? curr.confidence : prev.confidence_min,
			dupes_ratio: prev.dupes_ratio + (curr.duplicates_60 > 1),
			confidence_counts: {
				...prev.confidence_counts,
				[curr.confidence]: prev.confidence_counts[curr.confidence]
					? prev.confidence_counts[curr.confidence] + 1
					: 1,
			},
		};
	};

	const intialMetaData = {
		entities_count: 0,
		confidence_avg: 0,
		confidence_max: 0,
		confidence_min: 100,
		dupes_ratio: 0,
		confidence_counts: {},
	};
	const reducedMetaData = reducedTerms.reduce(metaReducer, intialMetaData);
	const metadata = {
		...reducedMetaData,
		confidence_avg: reducedMetaData.confidence_avg / reducedMetaData.entities_count,
		dupes_ratio: reducedMetaData.dupes_ratio / reducedMetaData.entities_count
	}
	return metadata;
};


const text = `The theory of relativity usually encompasses two interrelated theories by Albert Einstein: special relativity and general relativity, proposed and published in 1905 and 1915, respectively.[1] Special relativity applies to all physical phenomena in the absence of gravity. General relativity explains the law of gravitation and its relation to other forces of nature.[2] It applies to the cosmological and astrophysical realm, including astronomy.[3]

The theory transformed theoretical physics and astronomy during the 20th century, superseding a 200-year-old theory of mechanics created primarily by Isaac Newton.[3][4][5] It introduced concepts including 4-dimensional spacetime as a unified entity of space and time, relativity of simultaneity, kinematic and gravitational time dilation, and length contraction. In the field of physics, relativity improved the science of elementary particles and their fundamental interactions, along with ushering in the nuclear age. With relativity, cosmology and astrophysics predicted extraordinary astronomical phenomena such as neutron stars, black holes, and gravitational waves.[3][4][5]`

const smallerText = `The theory of relativity usually encompasses two interrelated theories by Albert Einstein: special relativity and general relativity, proposed and published in 1905 and 1915, respectively.`

const main = async () => {
	const result = await annotateText(smallerText);
	console.log(result);
}

await main();