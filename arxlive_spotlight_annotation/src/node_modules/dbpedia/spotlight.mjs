import * as _ from 'lamb'
import { fetch } from 'undici';

import { update } from 'es/update.mjs'
import { spotlightEndpoint, confidenceValues } from 'conf/config.mjs';
import { uniquesByStringifiedObjectValues } from '../util.mjs' // FIXME not the way we want to import
import { stringify } from '@svizzle/utils';

/**
 * The resource object that the spotlight tool responds with. Each resource corresponds to a DBpedia URI.
 * @typedef SpotlightResource
 * @type {Object}
 * @property {string} @URI - the Unique Resource Identifier for this resource.
 * @property {number} @support - the support for the annotated resource (see {@link SpotlightAnnotation})
 * @property {string} @types - the types the resource belongs to in the ontology.
 * @property {string} @surfaceForm - the original string used to produce this resource.
 * @property {number} @offset - the index at which the surface form was found in the provided text.
 * @property {number} @similarityScore - cosine similarity between the context vectors and the context surrounding the surface form.
 * @property {number} @percentageOfSecondRank - the relative difference in topic score between the first and the second ranked resource.
 */

/**
 * The annotation response. This object is the response to a call made when annotating a piece of text.
 * @typedef SpotlightAnnotation
 * @type {Object}
 * @property {string} text - text to be annotated.
 * @property {string} confidence - confidence score for disambiguation / linking.
 * @property {number} support - how prominent is this entity in Lucene Model, i.e. number of inlinks in Wikipedia
 * @property {string} types - types filter (Eg.DBpedia:Place).
 * @property {string} sparql - SPARQL filtering
 * @property {string} policy - (whitelist) select all entities that have the same type; (blacklist) - select all entities that have not the same type.
 * @property {SpotlightResource[]} Resources - the resources found for the supplied text.
 */

/**
 * @function castAnnotation
 * @description the Spotlight API returns the annotations with certan values cast as strings.
 * This function recasts the values back to their appropriate types.
 * @param {SpotlightAnnotation} annotation
 * @returns the Spotlight annotation, correctly parsed and casted
 */
const castAnnotation = (annotation) => {
	const Resources = annotation.Resources
		? annotation.Resources.map((r) => {
				return {
					...r,
					'@support': parseInt(r['@support']),
					'@offset': parseFloat(r['@offset']),
					'@similarityScore': parseFloat(r['@similarityScore']),
					'@percentageOfSecondRank': parseFloat(
						r['@percentageOfSecondRank']
					),
				};
		  })
		: null;
	return {
		...annotation,
		'@confidence': parseFloat(annotation['@confidence']),
		'@support': parseInt(annotation['@support']),
		Resources,
	};
};
/**
 * @function annotate
 * @description Returns an annotation object for the specified inputs.
 * @param {string} text - Text to annotate
 * @param {float} confidence - Confidence with which to annotate
 * @param {Object} [options] - Options object for the annotation process
 * @param {string} [options.endpoint] - Endpoint url where the Spotlight process runs. Defaults to the Docker container running on Nesta's EC2 instance.
 * @returns {SpotlightAnnotation} Spotlight annotation for given input paramaters
 */
export const annotate = async (
	text,
	confidence,
	{ endpoint = spotlightEndpoint } = {}
) => {
	const url = new URL(endpoint);
	const body = `text=${text}&confidence=${confidence}`;
	const response = await fetch(url, {
		method: 'POST',
		headers: {
			Accept: 'application/json',
			'content-type': 'application/x-www-form-urlencoded',
		},
		body: encodeURI(body),
	});
	if (!response.ok) {
		throw new Error(`Annotation failed\nResponse: ${stringify(response)}`)
	}
	const annotation = await response.json();
	return castAnnotation(annotation);
};

/**
 * For our purposes, we simplify the {@link SpotlightResource} object.
 * All properties below are the exact same.
 * @typedef ReducedResource
 * @type {Object}
 * @property {string} URI - the Unique Resource Identifier for this resource.
 * @property {string} surfaceForm - the original string used to produce this resource.
 * @property {number} similarityScore - cosine similarity between the context vectors and the context surrounding the surface form.
 * @property {number} percentageOfSecondRank - the relative difference in topic score between the first and the second ranked resource.
 */

/**
 *
 * @typedef ParsedAnnotation
 * @type {Object}
 * @property {ReducedResource[]} results - an array of simplified results.
 * @property {number} confidence - the confidence at which these results were annotated.
 */

/**
 * @function parseAnnotationResults
 * @description this function takes an array of Annotation objects and simplifies them.
 * @param {SpotlightAnnotation} spotlightAnnotation - an object returned by {@link annotate}
 * @returns {ParsedAnnotation} parsed Annotation.
 */
export const parseAnnotationResults = (spotlightAnnotation) => {
	const resultSubset = spotlightAnnotation.Resources
		? spotlightAnnotation.Resources.map((result) => {
				return {
					URI: result['@URI'],
					surfaceForm: result['@surfaceForm'],
					similarityScore: result['@similarityScore'],
					percentageOfSecondRank: result['@percentageOfSecondRank'],
				};
		  })
		: [];

	return {
		confidence: spotlightAnnotation['@confidence'],
		results: resultSubset,
	};
};

/**
 * The final form of resource, this is the same as {@link ReducedResource}, however
 * the confidence property has been added to the objects values.
 * All properties below are the exact same.
 * @typedef DBpediaEntity
 * @type {Object}
 * @property {string} URI - the Unique Resource Identifier for this resource.
 * @property {string} surfaceForm - the original string used to produce this resource.
 * @property {number} similarityScore - cosine similarity between the context vectors and the context surrounding the surface form.
 * @property {number} percentageOfSecondRank - the relative difference in topic score between the first and the second ranked resource.
 * @property {number} confidence - the highest confidence at which this resource could be found. This means that all annotations performed at a lower confidence than the one given here will also produce this annotation.
 */

/**
 * @function reduceAnnotationResults
 * @description Maps {@link ParsedAnnotation} objects using their confidedence.
 * @param {Object.<string, ParsedAnnotation>} parsedAnnotationByConfidence - an object where {@link ReducedResource} objects are mapped by the condience with which they were produced.
 * @returns {DBpediaEntity[]} - a list of annotated entities.
 */
export const reduceAnnotationResults = (parsedAnnotationByConfidence) => {
	const seen = new Set();
	const confidenceKeys = confidenceValues.map(n => n.toFixed(1)).reverse();
	const reducedTerms = confidenceKeys.reduce((prev, confidence) => {
		const terms = parsedAnnotationByConfidence[confidence] || [];
		const unseenTerms = terms.filter((term) => !seen.has(term.URI));
		return prev.concat(
			unseenTerms.map((term) => {
				seen.add(term.URI);
				return { ...term, confidence: parseFloat(confidence) };
			})
		);
	}, []);
	const uniqueTerms = uniquesByStringifiedObjectValues(reducedTerms);
	return uniqueTerms
};

/**
 * Results for the higher level process of annotating an ElasticSearch document.
 * @typedef documentAnnotationResult 
 * @type {Object}
 * @property {Object} document - the ElasticSearch document supplied for annotation.
 * @property {DBpediaEntity[]} annotations - a list of annotations for the supplied document.
 */

/**
 * @function annotateDocument
 * @description takes an Elastic search document from Arxlive and annotates the abstract_article field.
 * @param {Object} doc - an ElasticSearch document from the Arxlive domain.
 * @param {string} field - the field of the docment to use as text for the annotation
 * @param {string} endpoint - the endpoint pointing to the Spotlight REST API.
 * @return {documentAnnotationResult} - the annotations for this document
 */
export const annotateDocument = async (
	doc,
	field,
	endpoint = spotlightEndpoint
) => {
	const spotLightPromises = confidenceValues.map((confidence) =>
		annotate(doc._source[field], confidence, {
			endpoint,
		})
	);
	
	/** @type {SpotlightAnnotation[]} */
	const spotlightResults = (await Promise.all(spotLightPromises)).filter(
		(r) => 'Resources' in r
	);

	/** @type {ParsedAnnotation[]} */
	const spotlightTerms = spotlightResults.map(parseAnnotationResults);

	const termsByConfidence = spotlightTerms.reduce((map, obj) => {
		map[obj.confidence] = obj.results;
		return map;
	}, {});

	const reducedTerms = reduceAnnotationResults(termsByConfidence);
	return {
		document: doc,
		annotations: reducedTerms
	}
};

/**
 * @function uploadAnnotatedDocument
 * @description abstracts process of uploading document, to avoid uploading empty annotations 
 * @param {Object} annotations - the dbpedia annotations provided by {@link annotatedDocument}
 * @param {string} id - id of document to update
 * @param {string} domain - domain on which to upload
 * @param {*} index - index on which to upload
 * @returns {Promise} a promise indicating status of upload process
 */
export const uploadAnnotatedDocument = async (annotations, id, domain, index) => { 
	// no point in uploading if the doc/payload is empty
	if (Object.keys(annotations).length === 0) {
		return Promise.resolve();
	}
	return update(domain, index, id, {
		dbpedia_entities: annotations,
	});
}
