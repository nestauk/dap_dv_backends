import * as _ from 'lamb';

import { getValue, isIterableLongerThan1, stringify } from '@svizzle/utils';
import { dbr, dbo, prefixes } from 'dbpedia/util.mjs';
import { loadOntology } from 'dbpedia/ontology.mjs';
import { query } from 'sparql/query.mjs';

const sanitizeInput = input => {
	const URIs = typeof input === 'string' ? [input] : input;
	const sanitizedURIs = _.map(URIs, URI =>
		URI.charAt(0) !== '<'
			? URI.startsWith(dbr) ? `<${URI}>` : `<${dbr}${URI}>`
			: URI
	);
	return sanitizedURIs;
};

const buildQuery = queries => {
	const body = _.join(queries, '\nUNION\n');
	const sparql = `
	${prefixes}
	SELECT * WHERE {
		${body}
	}`;
	return sparql;
};

const makeRequest = async sparql => {
	const { results } = await query(sparql);
	const values = _.map(results.bindings, _.mapValuesWith(getValue));
	return values;
};

/**
 * @function getEntityDetails
 * @description provides details such as imageURL and abstract for supplied DBpedia URIs
 * @param {String|String[]} input - a single DBpedia URI or a list of URIs.
 * @returns a list of entities for the supplied DBPedia URIs.
 */
export const getEntityDetails = async input => {
	const sanitizedURIs = sanitizeInput(input);
	const queries = _.map(sanitizedURIs, URI =>
		`{
			BIND (${URI} as ?URI)
			OPTIONAL { 
				${URI} dbo:abstract ?abstract .
				FILTER (langMatches(lang(?abstract),"en"))
			}
			OPTIONAL { ${URI} prov:wasDerivedFrom ?derivedFrom . }
			OPTIONAL { ${URI} dbo:thumbnail ?imageURL . }
		}`,
	);
	const sparql = buildQuery(queries);
	const values = await makeRequest(sparql);

	// filter out bad encodings
	const filteredValues = _.map(values, entity => {
		if ('imageURL' in entity) {
			if (entity.imageURL.includes('ï¿½')) {
				const { imageURL, ...rest } = entity;
				return rest;
			}
		}
		return entity;
	});

	return filteredValues;
};

export const isDisambiguation = async input => {
	const sanitizedURIs = sanitizeInput(input);
	const queries = _.map(sanitizedURIs, URI =>
		`{
			BIND (${URI} as ?title)
			OPTIONAL { ${URI} dbo:wikiPageDisambiguates ?resource . }
		}`,
	);
	const sparql = buildQuery(queries);
	const results = await makeRequest(sparql);
	const groups = _.group(results, _.getKey('title'));

	// if the dbo:wikiPageDisambiguates predicate returns at least one value
	// for the URI, then it's a disambiguation page. As the title binding
	// will always be found, we check for length > 1
	const disambiguations = _.mapValues(groups, isIterableLongerThan1);
	return disambiguations;
};

export const getClasses = async (
	input,
	{ 	depth=Infinity,
		squash=true,
		fullURI=true } = {}
) => {

	const sanitizedURIs = sanitizeInput(input);
	const queries = _.map(sanitizedURIs, URI =>
		`{
			BIND (${URI} as ?title)
			OPTIONAL { ${URI} rdf:type ?type . }
		}`,
	);
	const sparql = buildQuery(queries);
	const results = await makeRequest(sparql);
	const groups = _.group(results, _.getKey('title'));
	const types = _.mapValues(groups, group => _.map(group, _.getKey('type')));
	const classFilter = await loadOntology(depth);
	const filteredTypes = _.mapValues(
		types,
		typeList => {
			const filtered = _.filter(typeList, t => t in classFilter);
			const squashed = squash
				? filtered
				: _.map(filtered, key => _.getIn(classFilter, key));
			const URIs = fullURI
				? squashed
				: JSON.parse(stringify(squashed).replaceAll(dbo, ''));
			return URIs;
		}
	);
	console.log(fullURI);
	return filteredTypes;
};

const main = async () => {
	const result = await getClasses(['Earth', 'Moon'], { fullURI: true, squash: false });
	console.log(result);
};

await main();
