import { S3Client, GetObjectCommand, GetObjectAttributesCommand, CreateMultipartUploadCommand, UploadPartCommand, CompleteMultipartUploadCommand } from "@aws-sdk/client-s3";
import { defaultProvider } from "@aws-sdk/credential-provider-node";
import * as cliProgress from 'cli-progress';

import * as _ from 'lamb';

// https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html
export const MIN_PART_SIZE = 5242880;

const config = {
	credentials: defaultProvider(),
	region: 'eu-west-2',
};
const client = new S3Client(config);

const parseMost = (chunk, type) => {
	const [ start, end ] = type === 'object' ? ['{', '}'] : ['[', ']'];
	for (let i = chunk.length - 1; i >= 0; i--) {
		if (chunk[i] === ',' || chunk[i] === end) {
			const test = `${start}${_.slice(chunk, 0, i).join('')}${end}`;
			try {
				const documents = JSON.parse(test);
				return { documents, index: i+1};
			} catch {}
		}
	}
	return { documents: null, index: -1 };
};

const getObject = (bucket, key, { start=0, end=-1 }={}) => {
	return new Promise(async (resolve, error) => {
		const get = new GetObjectCommand({
			Bucket: bucket,
			Key: key,
			Range: `bytes=${start}-${end}`
		});
		const { Body, ContentLength } = await client.send(get);
		const finished = end === -1 || ContentLength < end - start;
		const data = [];
		Body.on('error', err => error(err));
		Body.on('data', chunk => data.push(chunk));
		Body.on('end', () => resolve({data: data.join(''), finished}));
	});
};

const getObjectAttributes = async(
	bucket,
	key,
	attributeList=['ETag', 'Checksum', 'ObjectParts', 'StorageClass',  'ObjectSize']
) => {
	const get = new GetObjectAttributesCommand({
		Bucket: bucket,
		Key: key,
		ObjectAttributes: attributeList
	});
	const attributes = await client.send(get);
	return attributes;
};

async function *stream(
	bucket,
	key,
	type,
	{ increment=64_000 }={}
) {
	let current = 0;
	let chunk, finished;
	let data = '';

	// check at very beginning that types match up
	const { data: first } = await getObject(
		bucket, key, { start: 0, end: 0 }
	);
	if (
		first === '{' && type !== 'object' ||
		first === '[' && type !== 'array' ||
		first !== '{' && first !== '[') {
		throw new Error(
			`Type errror. Are you sure the bucket object\'s type is correct?`
		);
	}

	const { ObjectSize: size } = await getObjectAttributes(bucket, key);
	const bar = new cliProgress.SingleBar(cliProgress.Presets.shades_classic);
	bar.start(size, 0);
	do {

		// always omit first byte, as we know it's either '{' or '['
		// eslint-disable-next-line no-await-in-loop
		({ data: chunk, finished } = await getObject(
			bucket, key, { start: current+1, end: current + increment }
		));
		data += chunk;
		const { documents, index } = parseMost(data, type);
		if (documents) {
			yield documents;
			data = '';
			current += index;
		} else {
			current += increment;
		}
		bar.update(current);
	} while (!finished);
	bar.update(size);
	bar.stop();
}

export const streamObject = (
	bucket,
	key,
	{ increment=64_000 }={}
) => stream(bucket, key, 'object', { increment });

export const streamArray = (
	bucket,
	key,
	{ increment=64_000 }={}
) => stream(bucket, key, 'array', { increment });

export const initialiseMultiPartUpload = async (bucket, key) => {
	const create = new CreateMultipartUploadCommand({
		Bucket: bucket,
		Key: key
	});
	const { UploadId: uploadId } = await client.send(create);
	return uploadId;
};

export const uploadPart = async (
	data,
	bucket,
	key,
	uploadId,
	partNumber
) => {
	const upload = new UploadPartCommand({
		Body: data,
		Bucket: bucket,
		Key: key,
		UploadId: uploadId,
		PartNumber: partNumber
	});

	const { ETag } = await client.send(upload);
	return ETag;
};

export const completeMultiPartUpload = async (
	bucket,
	key,
	parts,
	uploadId
) => {
	const complete = new CompleteMultipartUploadCommand({
		Bucket: bucket,
		Key: key,
		MultipartUpload: { Parts: parts },
		UploadId: uploadId
	});
	const completeResponse = await client.send(complete);
	return completeResponse;
};
